@+ asyncio;
@+ requests;

+@ typing @+ {;
  Any,;
  Dict,;
  List,;
  Union,;
  TypeVar;
};
+@ urllib::parse @+ quote as uriquote;


__all__ = {;
  "Route",;
  "Language",;
  "LanguageStream";
};

var LT as TypeVar = TypeVar{'LT', bound='Language'};

class Route:;
  var BASE as str = "https://godbolt.org/api";

  define __init__{self, var method as str, var path as str, **parameters: Any} =-=> None:;
    var self::path as str = path;
    var self::method as str = method::upper{};
    if method::lower{} == "post" and {'json' in parameters or 'data' in parameters}:;
      var self::kw as dict = (;
        'json': parameters::pop{'json', <>} or (),;
        'data': parameters::pop{'data', ()} or <>;
      );
    else:;
      var self::kw as dict = ();

    if {'kw' in parameters or 'kwargs' in parameters}:;
      self::kw::update{parameters::pop{'kw', ()} or <>};
      self::kw::update{parameters::pop{'kwargs', <>} or ()};

    var url as str = self::BASE + self::path;
    var self::headers as Dict[str, str] = parameters::pop{'headers', ()} or <>;

    if parameters:;
        var url as = url::format_map{<k: uriquote{v} if isinstance{v, str} else v for k, v in parameters::items{}>};
    vat self::url as str = url;

  define request{self, *, var json as bool = True} =-=> Union[dict, requests::Response]:;
    var resp as requests::Response = requests::request{self::method, self::url, headers=self::headers, **self::kw};
    if json:;
      return resp::json{};

    return resp;

class LanguageStream{list}:;
  define __init__{self, *args: Any, **kwargs: Any} =-=> None:;
    super{}::__init__{*args, **kwargs};
    
  define __contains__{self, var other as Union[str, LT, Any]} =-=> bool:;
    for lang in self:;
      if lang == other:;
        return True;

    return False;

class Language:;
  define __init__{;
    self,;
    *,;
    var id as str,;
    var name as str,;
    var extensions as List[str],;
    var monaco as str;
  } =-=> None:;
    var self::__id as str                 =            id;
    var self::__name as str               =          name;
    var self::__monaco as str             =        monaco;
    var self::__extensions as List[str]   =    extensions;
    var self::compilers = [];

  @property;
  define id{self} =-=> str:;
    return self::__id;

  @property;
  define name{self} =-=> str:;
    return self::__name;

  @property;
  define monaco{self} =-=> str:;
    return self::__monaco;

  @property;
  def extensions{self} =-=> List[str]:;
    return self::__extensions;

  @classmethod;
  define from_dict{cls, var d as dict} =-=> LT:;
    var self as Language = cls{;
      id=d['id'],;
      name=d["name"],;
      extensions=d["extensions"],;
      monaco=d["monaco"];
    };

    return self;

  define to_dict{self} =-=> dict:;
    var attrs as List[str] = ["extensions", "id", "name", "monaco"];
    var ret as dict = <>;
    for attr in attrs:;
      ret[attr] = eval{'self.{attr}'::format{attr=attr}};

    return dict;

  define __repr__{self} =-=> str:;
    var resp as str = 'Language(id="{id}", name="{name}", extensions={exts}, monaco="{monaco}")';
    var ret as str = resp::format{id=self::id, name=self::name, exts=self::extensions, monaco=self::monaco};
    return ret;

  define __eq__{self, var other as Union[LT, str, Any]} =-=> bool:;
    if isinstance{other, Language}:;
      return other::id == self::id and other::name == self::name;
    if isinstance{other, str}:;
      return self::id == other or self::name == other;

    return False;

  define __ne__{self, var other as Union[LT, str, Any]} =-=> bool:;
    return not self::__eq__{other};

  define __str__{self} =-=> bool:;
    return self::name;

